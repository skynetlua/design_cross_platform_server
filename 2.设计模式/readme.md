**技术框架实质就是建立一种标准的工作流，让更多的人参与，更低成本地实现目标。**

1. 项目使用CMake管理，以Linux开源系统为标准，在windows上缺少的，模仿Linux造一个，实现一份代码跑全部平台。
2. 字符编码采用utf8，调用win32接口，直接在底层把unicode转utf8。
3. 代码风格采用骆驼峰形式
```cpp
class DemoClass //类名首字母大写，骆驼峰
{
  	int parramArg_; //变量名末尾有_，非静态变量首字母小写
  	static int ParramArg_;//变量名末尾有_，静态变量首字母大写
 	static void FuncA(){}//函数名末尾无有_，静态函数首字母小写
  	void funcA(){}//函数名末尾无有_，非静态函数首字母小写
};
```
4. 设计模式上选择，人脑比较容易接受的方式，面向对象、状态机和组件设计等。模块组件化，让设计模式标准化，实现组件通用化，避免没必要的重复造轮子。

## 一、面向对象设计
编程设计多种多样，AI只是人脑的工具，作为人脑的工具，那么这个工具要更容易被人脑使用，而不是人脑无法驾驭，否则，这个工具就会被抛弃。我们希望做出的工具，有更多的人愿意去使用，我们可以拿来卖钱买饭吃。

面向对象设计，把业务逻辑封装类似实体物品，让人脑更容易接受和使用。

我们设计的服务器框架，服务器主要功能是加工数据、提供数据和数据通讯，就像一座数据工厂，里面有各种各样的数据加工机器人。机器人有最简单的两点：属性和行为。

我们用变量记录和描述属性，用函数描述行为。
```cpp
机器人
	属性：编号，名称，类型
  	行为：
   行走（）
   ｛
   		//执行行走
   ｝
   工作（）
   ｛
   		// 执行工作任务
   ｝
```
如果有资金支持，我们可以开发一个汉语编译器工具，把上述内容编译成二进制程序，就可以在电脑上执行。很可惜，排得上号的编译器（gcc、cl、llvm、ndk等）都不是国产的。
从上面可以看出，面向对象只是一种逻辑，跟编程语言无关，我们将用C语言和C++语言各实现一个robot对象。
C语言版本：
```c
struct Robot
{
	int id;
 	const char* name;
  	int type;
}
void Robot_move(Robot* this)
{
  printf("move:id = %d\n", this->id);
}
void Robot_work(Robot* this)
{
  printf("work:id = %d\n", this->id);
}
int main()
{
	Robot robot;
	Robot_move(&robot);
	Robot_work(&robot);
	return 0;
}
```
C++版本：

```cpp
struct Robot
{
 	int id_;
  	std::string name_;
  	int type_;
  	void move()
   {
      std::cout << "move: id = " << id_ << std::endl;
    }
   void work()
   {
      std::cout << "work: id = " << id_ << std::endl;
    }
}
int main()
{
	Robot robot;
	robot.move();
	robot.work();
}
```
通过两个版本的分析，可以看出C++编译器对面向对象提供了更好的语法便利。这就是C++语法糖，代价就是损失一些性能，好处就是提高写代码效率，代码更少，更容易维护。

## 二、组件设计
我们的机器人需要接收消息，接收到消息以后，需要进行加工，然后把加工的数据，通过消息发出去。我们有成千上万种数据加工业务，我们需要设计各种各样的机器人。
如果按照继承的方式，robot作为父类，需要实现各种各样的子类，这种方式虽然也可以做到业务分离，但是复用和共享很困难。我们希望像汽车一样，标准化各种零部件，想要什么价位和性能的汽车，就选择组装什么样的零件。
这个就是组件设计。设计一个类Com，作为组件基类，把单一功能的逻辑，作为一个组件。Robot作为集合类，需要什么样的Robot，就组装什么样的组件。
```cpp
```

## 三、状态机设计


